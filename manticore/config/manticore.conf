source dbconnect {
    type = pgsql
    sql_host = std-base01.services.lab.x5.ru
    sql_user = tso
    sql_pass = tso1245
    sql_db = tso
    sql_port = 5432
}

source feed : dbconnect
{
        sql_query = WITH products as ( \
                        select p.product_id, \
                               p.name, \
                               p.translit, \
                               p.file_id,\
                               p.is_fractional_nominal, \
                               p.is_fractional, \
                               p.pre_packing_step, \
                               p.pre_quantum, \
                               p.category_sap_id, \
                               p.plu,\
                               p.is_packaging_sale, \
                               p.nq_packing_quantum, \
                               p.packing_quantum, \
                               p.vetcatrisk, \
                               p.pre_brand_translit \
                        from product.product as p \
                        WHERE p.product_status_id IN (4, 5, 6) \
                        ORDER BY p.product_id \
                    ), \
                         stock_by_shops AS ( \
                             SELECT p.product_id, s.region_id, SUM(ps.amount) AS qnt, s.shop_id, s.max_vetcatrisk \
                             FROM products as p \
                                      INNER JOIN product.shipment as ps on p.product_id = ps.product_id \
                                      inner join product.shipment_to_shop as sts on ps.shipment_id = sts.shipment_id \
                                      INNER JOIN setting.shop as s ON (sts.shop_id = s.shop_id) \
                             GROUP BY p.product_id, s.region_id, s.shop_id \
                         ), \
                         reviews AS ( \
                             SELECT ptr.product_id, \
                                    COUNT(r.*) as review_count, \
                                    round(AVG(r.rating) * 2) AS rating \
                             FROM products as p \
                                      INNER JOIN product.product_to_review ptr on p.product_id = ptr.product_id \
                                      INNER JOIN content.review r on ptr.review_id = r.review_id \
                             WHERE r.review_status_id = 5 \
                             GROUP BY ptr.product_id \
                         ), \
                         barcodes AS ( \
                             SELECT b.product_id, json_agg(b.body) AS barcodes \
                             FROM products as p \
                                      INNER JOIN product.barcode as b on p.product_id = b.product_id \
                             WHERE b.is_valid = true \
                             GROUP BY b.product_id \
                         ), \
                         product_property_ids as ( \
                             select ptcs.product_id, \
                                    array_agg(distinct ptt.property_id) as props \
                             from product.product_to_category_site as ptcs \
                                      join product.category_site as cs on ptcs.category_site_id = cs.category_site_id \
                                      join product.property_to_template as ptt on cs.filter_template_id = ptt.template_id \
                             where ptcs.is_primary = true \
                               and ptcs.product_id in (select product_id from products) \
                             group by ptcs.product_id \
                             order by ptcs.product_id desc \
                         ), \
                         values as ( \
                             select ptv.product_id, \
                                    json_object_agg(distinct pr_prop.name, \
                                                    ( \
                                                        select distinct on (pr_prop.property_id) array_agg(pv2.data) \
                                                        from product.product_to_value as ptv2 \
                                                                 join product.value as pv2 on ptv2.value_id = pv2.value_id \
                                                        where ptv2.product_id = ptv.product_id \
                                                          and pv2.property_id = pr_prop.property_id \
                                                    ) \
                                        ) as values_json \
                             from product.product_to_value as ptv \
                                      join product_property_ids on ptv.product_id = product_property_ids.product_id \
                                      join product.property as pr_prop on ptv.property_id = pr_prop.property_id \
                             where pr_prop.property_id = any (product_property_ids.props) \
                             group by ptv.product_id \
                         ), \
                         special_props as ( \
                              select ptv.product_id, \
                                     json_object_agg( \
                                         distinct pr_prop.property_id, \
                                         jsonb_build_object( \
                                                 'name', pr_prop.name, \
                                                 'data', ( \
                                                     select distinct on (pr_prop.property_id) array_agg(pv2.data) \
                                                     from product.product_to_value as ptv2 \
                                                              join product.value as pv2 on ptv2.value_id = pv2.value_id \
                                                     where ptv2.product_id = ptv.product_id \
                                                       and pv2.property_id = pr_prop.property_id \
                                                 ) \
                                             ) \
                                     ) as values_jsonb \
                              from product.product_to_value as ptv \
                                       join product_property_ids on ptv.product_id = product_property_ids.product_id \
                                       join product.property as pr_prop on ptv.property_id = pr_prop.property_id \
                              where pr_prop.property_id in (1978, 1979, 1980, 1981, 1830) /* 1978 - id свойства "Ширина", 1979 - id свойства "Высота", 1980 - id свойства "Длина" (Глубина), 1981 - id свойства "Вес (брутто)", 1830 - id свойства "Состав" */ \
                              group by ptv.product_id \
                         ), \
                         suppliers as ( \
                             select p2supplier.supplier_id, \
                                    p2supplier.product_id \
                             from supplier.supplier \
                                      join supplier.product_to_supplier as p2supplier on p2supplier.supplier_id = supplier.supplier_id \
                         ), \
                        category_sites AS ( \
                           SELECT \
                               ptcs.product_id, \
                               array_to_string(array_agg(ptcs.category_site_id),',') as category_sites \
                           FROM product.product_to_category_site as ptcs \
                           GROUP BY ptcs.product_id \
                        ), \
                        price_shop AS ( \
                            SELECT \
                            	ps.product_id, \
                            	ps.current_price, \
                            	ps.current_old_price, \
                            	ps.quantum_price, \
                            	s.region_id \
                            FROM product.price_shop ps  \
                            	INNER JOIN setting.shop s on ps.shop_id = s.shop_id \
                        ), \
                        product_images as ( \
                            select distinct on (ptf.product_id, f.file_type_id) \
                                f.file_id, ptf.product_id, f.file_type_id \
                            from product.product_to_file ptf \
                                inner join product.file f on ptf.file_id = f.file_id \
                            where ptf.deleted_at is null \
                                and f.layout = 3 \
                                and f.file_type_id IN (1, 10) \
                                and f.active_for_site = true \
                            order by ptf.product_id, f.file_type_id, ptf.sort \
                        ) \
                    SELECT \
  row_number() OVER() AS id, \
  p.product_id, \
                           p.name                                                                                             AS product_name, \
                           p.translit                                                                                         AS product_translit, \
                           pi.description, \
                           pi_main.file_id                                                                                    AS image_id, \
                           pi_quantum.file_id                                                                                 AS quantum_image_id, \
                           cs.name                                                                                            AS category_site_name, \
                           cs.category_site_id, \
                           cs.url                                                                                             AS category_url, \
                           csm.category_sites, \
                           CASE WHEN COALESCE(ps.current_price, 0) > COALESCE(price.current_price, 0) \
                                THEN COALESCE(ps.current_price, 0) \
                                ELSE COALESCE(price.current_price, 0) \
                           END AS price, \
                           CASE WHEN COALESCE(ps.current_old_price, 0) > COALESCE(price.current_old_price, 0) \
                                THEN COALESCE(ps.current_old_price, 0) \
                                ELSE COALESCE(price.current_old_price, 0) \
                           END AS old_price, \
                           COALESCE(ps.quantum_price, price.quantum_price)                                                    AS quantum_price, \
                           price.region_id, \
                           vendor.value_id                                                                                    AS vendor_id, \
                           vendor.data                                                                                        AS vendor_name, \
                           p.plu, \
                           coalesce(stock.qnt, 0)                                                                             AS qnt, \
                           coalesce(stock.qnt, 0) - coalesce(pts.reserved, 0)                                                 AS non_reserved_amount, \
                           barcodes.barcodes, \
                           r.review_count, \
                           r.rating, \
                           p.is_fractional_nominal, \
                           p.is_fractional, \
                           p.pre_packing_step, \
                           p.pre_quantum, \
                           stock.shop_id, \
                           values.values_json                                                                                 AS properties, \
                           special_props.values_jsonb->'1981'                                                                 AS weight_prop, \
                           special_props.values_jsonb->'1980'                                                                 AS length_prop, \
                           special_props.values_jsonb->'1979'                                                                 AS height_prop, \
                           special_props.values_jsonb->'1978'                                                                 AS width_prop, \
                           special_props.values_jsonb->'1830'                                                                 AS composition_prop, \
                           pi.is_need_to_price_monitor, \
                           pi.is_need_to_order, \
                           pa.activity_status, \
                           p.category_sap_id, \
                           p.is_packaging_sale, \
                           p.nq_packing_quantum, \
                           p.packing_quantum, \
                           p.pre_brand_translit, \
                           CASE WHEN vetcatrisk <= max_vetcatrisk THEN TRUE ELSE FALSE END                                    AS is_vetcatrisk_ok, \
                           suppliers.supplier_id \
                    FROM products AS p \
                             LEFT JOIN product.product_info AS pi ON (pi.product_id = p.product_id) \
                             LEFT JOIN barcodes ON (barcodes.product_id = p.product_id) \
                             LEFT JOIN values on p.product_id = values.product_id \
                             LEFT JOIN special_props on p.product_id = special_props.product_id \
                             INNER JOIN product.product_to_category_site AS p2cs ON \
                                 (p.product_id = p2cs.product_id AND p2cs.is_primary = true) \
                             LEFT JOIN category_sites as csm ON p.product_id = csm.product_id \
                             INNER JOIN product.category_site AS cs on p2cs.category_site_id = cs.category_site_id \
                             LEFT JOIN product_images AS pi_main ON (pi_main.product_id = p.product_id AND pi_main.file_type_id = 1) \
                             LEFT JOIN product_images AS pi_quantum ON (pi_quantum.product_id = p.product_id AND pi_quantum.file_type_id = 10) \
                             LEFT JOIN product.product_to_value AS p2v_vendor ON ( \
                            p2v_vendor.product_id = p.product_id \
                            AND p2v_vendor.property_id = 2571 \
                        ) \
                             LEFT JOIN product.value AS vendor ON (vendor.value_id = p2v_vendor.value_id) \
                             INNER JOIN product.price AS price ON (price.product_id = p.product_id) \
                             LEFT JOIN price_shop ps ON (ps.product_id = p.product_id AND ps.region_id = price.region_id) \
                             INNER JOIN stock_by_shops AS stock ON ( \
                            stock.product_id = p.product_id \
                            AND stock.region_id = price.region_id \
                        ) \
                            LEFT JOIN ( \
                                    SELECT sum(amount) as reserved, product_id, shop_id \
                                    FROM "order".position_to_shipment \
                                    group by product_id, shop_id \
                                ) as pts on ( \
                                    p.product_id = pts.product_id \
                                    AND stock.shop_id = pts.shop_id \
                                ) \
                            INNER JOIN product.product_activity as pa ON ( \
                            stock.shop_id = pa.shop_id \
                            AND p.product_id = pa.product_id \
                        ) \
                             LEFT JOIN suppliers ON ( \
                        p.product_id = suppliers.product_id \
                        ) \
                        LEFT JOIN reviews as r ON r.product_id = p.product_id;
                         
        sql_attr_uint = product_id
    sql_attr_string = product_name
    sql_attr_string = product_translit
    sql_field_string = description
    sql_attr_uint = image_id
    sql_attr_uint = quantum_image_id
    sql_attr_string = category_site_name
    sql_attr_uint = category_site_id
    sql_attr_string = category_url
    sql_attr_float = price
    sql_attr_float = old_price
    sql_attr_float = quantum_price
    sql_attr_float = pre_packing_step
    sql_attr_float = pre_quantum
    sql_attr_float = qnt
    sql_attr_float = non_reserved_amount
    sql_attr_float = rating
    sql_attr_uint = region_id
    sql_attr_uint = vendor_id
    sql_attr_string = vendor_name
    sql_attr_string = plu
    sql_attr_string = barcodes
    sql_attr_uint = review_count
    sql_attr_bool = is_fractional
    sql_attr_bool = is_fractional_nominal
    sql_attr_uint = shop_id
    sql_attr_string = properties
    sql_attr_string = weight_prop
    sql_attr_string = length_prop
    sql_attr_string = height_prop
    sql_attr_string = width_prop
    sql_attr_string = composition_prop
    sql_attr_bool = is_need_to_price_monitor
    sql_attr_bool = is_need_to_order
    sql_attr_uint = activity_status
    sql_attr_uint = category_sap_id
    sql_attr_bool = is_packaging_sale
    sql_attr_uint = nq_packing_quantum
    sql_attr_uint = packing_quantum
    sql_attr_uint = supplier_id
    sql_attr_bool = is_vetcatrisk_ok
    sql_attr_string = pre_brand_translit
    sql_attr_multi = uint category_sites from field

}

index feed
{
    source                      = feed
    path                        = /var/lib/manticore/data/feed
    docinfo                     = extern
    mlock                       = 0
    morphology          = stem_enru
    min_word_len        = 2
    charset_table       = 0..9, A..Z->a..z, _, a..z, U+410..U+42F->U+430..U+44F, U+430..U+44F, U+0401->U+0435, U+0451->U+0435
    html_strip          = 1
    html_remove_elements = style, script
}

source product : dbconnect
{
    sql_query = WITH product_popularity AS ( \
                    SELECT \
                      pp.product_id AS product_id, \
                      json_object_agg(pp.region_id, pp.popularity::int) AS data \
                    FROM product.product_popularity AS pp \
                    GROUP BY pp.product_id \
                ), \
                product as ( \
                  SELECT \
                    pp.product_id, \
                    pp.is_alcohol, \
                    pp.is_adult, \
                    pp.vetcatrisk, \
                    pp.category_sap_id, \
                    pp.name, \
                    coalesce(pp.countries_world_id, pp.pre_country_id) as country_id, \
                    pp.gtd_count \
                  FROM product.product AS pp \
                  WHERE \
                    pp.product_status_id IN (4, 5, 6) \
                    AND pp.category_sap_id <> -1 \
                ), \
                product_activity as ( \
                  SELECT \
                    pp.product_id, \
                    array_agg(DISTINCT ppa.shop_id) as shop_activity_ids, \
                    array_agg(DISTINCT 's' || ppa.shop_id) as shop_activity_string_ids, \
                    array_agg(DISTINCT 's' || ppa.shop_id || 'mdd' || ppa.min_delivery_date) as min_delivery_dates \
                  FROM product AS pp \
                    LEFT JOIN product.product_activity ppa ON ppa.product_id = pp.product_id and ppa.is_active = true \
                  GROUP BY pp.product_id \
                ), \
                shop_product_activity as ( \
                  SELECT \
                    pp.product_id, \
                    array_agg(DISTINCT '"s' || pa.shop_id || '":' || coalesce(CASE WHEN pa.is_active THEN 1 ELSE 0 END, 0)) AS is_active \
                  FROM product as pp \
                    LEFT JOIN product.product_activity pa ON pa.product_id = pp.product_id \
                  GROUP BY pp.product_id \
                ), \
                product_price as ( \
                  SELECT \
                    pp.product_id, \
                    array_agg(DISTINCT '"r' || p_price.region_id || '":' || coalesce(CASE WHEN p_price.rule_price > 0 THEN p_price.rule_price ELSE p_price.price END, 0)) AS price \
                  FROM product as pp \
                    LEFT JOIN product.price p_price ON p_price.product_id = pp.product_id \
                  GROUP BY pp.product_id \
                ), \
                product_category as ( \
                  SELECT \
                    pp.product_id, \
                    (array_agg(DISTINCT ppcs.category_site_id) FILTER (WHERE pptcs.is_primary = TRUE))[1] AS category_site_id, \
                    (array_agg(DISTINCT ppcs.name) FILTER (WHERE pptcs.is_primary = TRUE))[1] AS category_site_name, \
                    array_agg(DISTINCT ppcs.category_site_id) AS category_site_ids, \
                    array_agg(DISTINCT 'c' || ppcs.category_site_id) AS category_site_string_ids, \
                    array_agg(DISTINCT ppcs.name) FILTER (WHERE ppcs.is_hidden = FALSE) AS category_site_names, \
                    (array_remove(array_agg(DISTINCT pcss.value), NULL)) AS category_site_name_synonyms \
                  FROM product AS pp \
                    INNER JOIN product.product_to_category_site pptcs ON pp.product_id = pptcs.product_id \
                    INNER JOIN product.category_site ppcs ON pptcs.category_site_id = ppcs.category_site_id AND ppcs.deleted_at IS NULL \
                    LEFT JOIN product.category_site_synonyms pcss ON pptcs.category_site_id = pcss.category_site_id \
                  GROUP BY pp.product_id \
                ), \
                sites AS ( \
                   SELECT \
                       p.product_id, \
                       array_to_string(array_agg(cs.site_id),',') as sites \
                   FROM product.product_to_category_site as p \
                   INNER JOIN product.category_site_to_site as cs ON cs.category_site_id = p.category_site_id \
                   WHERE p.is_primary = true \
                   GROUP BY p.product_id \
                ), \
                delivery_types AS ( \
                   SELECT \
                       ptdt.product_id, \
                       array_to_string(array_agg(ptdt.delivery_type_id),',') as delivery_types \
                   FROM product.product_to_delivery_type as ptdt \
                   GROUP BY ptdt.product_id \
                ), \
                product_synonym as ( \
                  SELECT \
                    pp.product_id, \
                    array_agg(DISTINCT pps.value) AS name_synonyms_array \
                  FROM product AS pp \
                    LEFT JOIN product.product_synonyms pps ON pp.product_id = pps.product_id \
                  GROUP BY pp.product_id \
                ), \
                product_type as ( \
                  SELECT \
                    pp.product_id, \
                    array_cat(array_agg(DISTINCT pv_type.data), array_agg(DISTINCT pvs_type.value)) AS type_array \
                  FROM product AS pp \
                    LEFT JOIN product.product_to_value pptv_type ON pp.product_id = pptv_type.product_id \
                    LEFT JOIN product.property_is_type_of_product ppitop ON pptv_type.property_id = ppitop.property_id \
                    LEFT JOIN product.value pv_type ON pptv_type.value_id = pv_type.value_id AND pv_type.property_id = ppitop.property_id \
                    LEFT JOIN product.value_synonyms pvs_type ON pv_type.value_id = pvs_type.value_id \
                  GROUP BY pp.product_id \
                ), \
                product_property AS ( \
                  SELECT \
                    pp.product_id, \
                    array_agg(DISTINCT ppr.name || ' ' || pv.data || ' ' || COALESCE(pvs.value, '') || ' ' || COALESCE(pm.name, '') || ' ' || COALESCE(pm.short, '') ) AS values_array, \
                    array_remove( \
                        array_cat( \
                            array_agg(DISTINCT (CASE WHEN pv.property_id = 147 THEN pv.data ELSE NULL END )), \
                            array_agg(DISTINCT (CASE WHEN pv.property_id = 147 THEN pvs.value ELSE NULL END )) \
                        ), \
                        NULL \
                    ) as manufacturer_name_array, \
                    array_remove( \
                        array_cat( \
                            array_agg(DISTINCT (CASE WHEN pv.property_id = 148 THEN pv.data ELSE NULL END )), \
                            array_agg(DISTINCT (CASE WHEN pv.property_id = 148 THEN pvs.value ELSE NULL END )) \
                        ), \
                        NULL \
                    ) as brand_name_array, \
                    (array_remove(array_agg(DISTINCT (CASE WHEN pv.property_id = 147 THEN pv.value_id ELSE NULL END )), NULL))[1] as manufacturer_id, \
                    (array_remove(array_agg(DISTINCT (CASE WHEN pv.property_id = 148 THEN pv.value_id ELSE NULL END )), NULL))[1] as brand_id \
                  FROM product AS pp \
                    LEFT JOIN product.product_to_value pptv ON pp.product_id = pptv.product_id \
                    LEFT JOIN product.property ppr ON pptv.property_id = ppr.property_id \
                    LEFT JOIN product.measure pm ON ppr.measure_id = pm.measure_id \
                    LEFT JOIN product.value pv ON pptv.value_id = pv.value_id \
                    LEFT JOIN product.value_synonyms pvs ON pv.value_id = pvs.value_id \
                  GROUP BY pp.product_id \
                ) \
                SELECT \
                  pp.product_id as id, \
                  pp.vetcatrisk, \
                  pp.category_sap_id, \
                  pcs.storing_type_id, \
                  s.sites, \
                  dt.delivery_types, \
                  pp.is_alcohol as is_alcohol, \
                  pp.is_adult as is_adult, \
                  array_to_string(product_type.type_array, ' ') as type, \
                  pp.name || ' ' || array_to_string(ps.name_synonyms_array, ' ') as name, \
                  get_trigram(pp.name || ' ' || array_to_string(ps.name_synonyms_array, ' ')) as name_trigram, \
                  c.category_site_name || ' ' || array_to_string(c.category_site_name_synonyms, ' ') as category_site_name, \
                  array_to_string(c.category_site_names, ' ') as category_site_names, \
                  array_to_string(product_property.brand_name_array, ' ') as brand_name, \
                  array_to_string(product_property.manufacturer_name_array, ' ') as manufacturer_name, \
                  array_to_string(values_array, ', ') as properties, \
                  regexp_replace(regexp_replace(ppi.description, E'<.*?>', '', 'g' ), E'[nr]+', ' ', 'g') as description, \
                  array_to_string(array_remove(array_cat(array_cat(array_cat(array['b' || product_property.brand_id, 'm' || product_property.manufacturer_id], category_site_string_ids), pa.shop_activity_string_ids), pa.min_delivery_dates), NULL), ',') as feature_field, \
                  json_build_object( \
                      'category_site_ids', c.category_site_ids, \
                      'category_site_id', c.category_site_id, \
                      'brand_id', product_property.brand_id, \
                      'manufacturer_id', product_property.manufacturer_id, \
                      'shop_ids', pa.shop_activity_ids \
                  ) as feature_json, \
                  '{' || array_to_string(product_price.price, ',') || '}' as price_json, \
                  '{' || array_to_string(spa.is_active, ',') || '}' as is_active_json, \
                  product_popularity.data as popularity, \
                  extract(epoch from now() at time zone 'utc')::int as updated_at \
                FROM \
                  product as pp \
                  JOIN product_category as c on pp.product_id = c.product_id \
                  LEFT JOIN product_synonym as ps on pp.product_id = ps.product_id \
                  LEFT JOIN product_price on pp.product_id = product_price.product_id \
                  LEFT JOIN product_property on pp.product_id = product_property.product_id \
                  LEFT JOIN product_activity as pa on pp.product_id = pa.product_id \
                  LEFT JOIN product_type on pp.product_id = product_type.product_id \
                  LEFT JOIN product_popularity ON pp.product_id = product_popularity.product_id \
                  LEFT JOIN product.product_info ppi ON pp.product_id = ppi.product_id \
                  LEFT JOIN sites s ON pp.product_id = s.product_id \
                  LEFT JOIN delivery_types dt ON pp.product_id = dt.product_id \
                  LEFT JOIN shop_product_activity as spa on pp.product_id = spa.product_id \
                  LEFT JOIN product.category_sap as pcs on pcs.category_sap_id = pp.category_sap_id \

    sql_field_string = type
    sql_attr_bool = is_alcohol
    sql_attr_bool = is_adult
    sql_attr_uint = storing_type_id
    sql_field_string = name
    sql_field_string = name_trigram
    sql_field_string = category_site_name
    sql_field_string = category_site_names
    sql_field_string = brand_name
    sql_field_string = manufacturer_name
    sql_field_string = properties
    sql_field_string = description
    sql_attr_json = popularity
    sql_field_string = feature_field
    sql_attr_json = feature_json
    sql_attr_json = price_json
    sql_attr_json = is_active_json
    sql_attr_timestamp = updated_at
    sql_attr_uint = vetcatrisk
    sql_attr_uint = category_sap_id
    sql_attr_multi = uint sites from field
    sql_attr_multi = uint delivery_types from field

}

index product
{
	source			= product
	path			= /var/lib/manticore/data/product
    docinfo			= extern
    mlock			= 0
    morphology		= stem_enru
    min_word_len	= 1
    charset_table   = 0..9, english, russian, U+0401->U+0435, U+0451->U+0435
    blend_chars     = +, -, &, /, U+0023
    ignore_chars    = U+00AD
    index_exact_words = 1
    min_infix_len   = 1
    html_strip      = 1
    html_remove_elements = style, script
}

source products : dbconnect
{
    sql_query = with p as ( \
            SELECT \
                pp.product_id, \
                pp.is_alcohol, \
                pp.is_adult, \
                pp.vetcatrisk, \
                pp.category_sap_id, \
                pp.file_id, \
                pp.name || ' ' || \
                COALESCE(string_agg(DISTINCT csk.keyword, ' '), '') ||  ' ' || \
                COALESCE(string_agg(DISTINCT csk.stemm, ' '), '') || ' ' || \
                COALESCE(string_agg(csw.word, ' '), '') AS name, \
                pp.name AS pure_name, \
                coalesce(pp.countries_world_id, pp.pre_country_id) as country_id, \
                pp.gtd_count, \
                pp.plu_type, \
                pp.category_id as category_id, \
                pp.is_fractional, \
                pp.is_fractional_nominal, \
                pp.pre_price_ratio, \
                pp.quantum_discount, \
                pp.is_packaging_sale, \
                pp.pre_quantum, \
                pp.translit, \
                pp.pre_packing_step, \
                CASE \
                    WHEN pp.is_packaging_sale = true THEN \
                    CASE \
                       WHEN pp.packing_quantum is NULL THEN pp.nq_packing_quantum \
                       ELSE pp.packing_quantum \
                    END \
                END as final_packing_quantum, \
                pp.pre_brand_translit \
            FROM product.product AS pp \
            LEFT JOIN content.synonym_to_product cstp ON cstp.product_id = pp.product_id \
            LEFT JOIN content.synonym_keyword csk ON csk.synonym_keyword_id = cstp.synonym_keyword_id AND csk.is_active = TRUE \
            LEFT JOIN content.synonym_word csw ON csw.synonym_keyword_id = csk.synonym_keyword_id \
            WHERE pp.product_status_id IN (4,5,6) \
            AND pp.category_sap_id <> -1 \
            AND pp.is_visible = TRUE \
            GROUP BY pp.product_id \
        ), \
        product_popularity AS ( \
            SELECT \
              pp.product_id AS product_id, \
              json_object_agg(pp.region_id, pp.popularity::int) AS data \
            FROM product.product_popularity AS pp \
            GROUP BY pp.product_id \
        ), \
        p_trademark as ( \
            select p.product_id, v.value_id, v.data \
            from p \
                inner join product.product_to_value p2v on p2v.product_id = p.product_id \
                inner join product.value v on v.value_id = p2v.value_id \
            where p2v.property_id = 148 \
        ), \
        cc as ( \
            SELECT \
                category_site_id, \
                unnest(ns_path||category_site_id) AS cat_id \
            FROM product.category_site \
            WHERE deleted_at IS NULL \
        ), \
        shops as ( \
            SELECT \
              DISTINCT ON (product_id, shop_id, region_id) \
              ps.product_id, \
              shop.shop_id, \
              shop.region_id \
            FROM product.shipment AS ps \
              INNER JOIN product.shipment_to_shop as sts on ps.shipment_id = sts.shipment_id \
              INNER JOIN setting.shop AS shop ON sts.shop_id = shop.shop_id \
              INNER JOIN product.product_activity AS pa \
                ON pa.shop_id = shop.shop_id AND pa.region_id = shop.region_id AND pa.product_id = ps.product_id \
            WHERE \
              pa.activity_status != 40 \
            UNION \
                SELECT \
                    pa.product_id, \
                    pa.shop_id, \
                    pa.region_id \
                FROM product.product_activity AS pa \
                INNER JOIN product.product AS pp ON pa.product_id = pp.product_id and pp.plu_type = 1 \
                WHERE \
                  pa.activity_status != 40 \
        ), \
        cats as ( \
            SELECT \
                product_id, \
                unnest( \
                    case \
                        when array_length(child.region_ids, 1) > 0 \
                        then child.region_ids \
                        else array[reg.region_id] \
                        end \
                ) as cats_region_id, \
                array_to_string(array_agg(DISTINCT cs.name),' ') AS cnames, \
                array_to_string(array_agg(DISTINCT cs.category_site_id),',') AS category_site_ids \
            FROM p \
            JOIN product.product_to_category_site p2cs using(product_id) \
            JOIN cc using(category_site_id) \
            JOIN product.category_site cs ON cs.category_site_id = cat_id \
            JOIN product.category_site as child ON p2cs.category_site_id = child.category_site_id \
            CROSS JOIN setting.region as reg \
            WHERE cc.cat_id != 1 \
            AND cs.deleted_at IS NULL \
            GROUP BY product_id, cats_region_id \
        ), \
        sites AS ( \
           SELECT \
               p.product_id, \
               array_to_string(array_agg(cs.site_id),',') as sites \
           FROM product.product_to_category_site as p \
           INNER JOIN product.category_site_to_site as cs ON cs.category_site_id = p.category_site_id \
           WHERE p.is_primary = true \
           GROUP BY p.product_id \
        ), \
        delivery_types AS ( \
           SELECT \
               ptdt.product_id, \
               array_to_string(array_agg(ptdt.delivery_type_id),',') as delivery_types \
           FROM product.product_to_delivery_type as ptdt \
           GROUP BY ptdt.product_id \
        ), \
        promos as ( \
            select \
                product_id, \
                region_id, \
                shop_id, \
                array_to_string(array_agg(promo_id),',') as promo_ids, \
                case when 4 = ANY(array_agg(promo_type_id)) then true else false end as has_filter_promo_n_plus, \
                product_sort_promo \
            from ( \
                SELECT \
                    sort as product_sort_promo, \
                    pp2p.product_id, \
                    pp2p.region_id, \
                    s.shop_id, \
                    shop_ids, \
                    promo_type_id, \
                    unnest(ARRAY[promo.promo_id,parent_promo_id]) AS promo_id \
                FROM promo.pre_promo_to_product pp2p \
                JOIN promo.promo USING(promo_id) \
                LEFT JOIN product.product_to_sort_promo USING(product_id) \
                JOIN shops s ON s.product_id = pp2p.product_id AND s.region_id = pp2p.region_id \
                WHERE pp2p.is_gift=FALSE \
                AND promo.is_active=TRUE \
                AND (shop_ids IS NULL OR s.shop_id = ANY (shop_ids)) \
            ) as ttt \
            where promo_id > 0 \
            group by product_id, region_id, shop_id, product_sort_promo \
        ), \
        reviews as ( \
            SELECT \
                product_id, \
                count(1) as feedbacks, \
                round(sum(rating) / count(1),2) AS rating \
            FROM product.product_to_review \
            JOIN content.review USING(review_id) \
            WHERE content.review.review_status_id = '5' \
            GROUP BY product_id \
        ), \
        is_new_badge AS ( \
            SELECT btp.product_id, \
                   btp.start_date, \
                   pb.description, \
                   pb.icon_upload_id, \
                   pb.url \
            FROM product.badge_to_product as btp \
            JOIN promo.badge as pb on pb.badge_id = btp.badge_id \
            WHERE btp.badge_id = 1 and btp.end_date >= NOW() \
        ), \
        props as ( \
            SELECT \
                product_id, \
                array_to_string(array_agg(v.value_id), ',') AS attrs, \
                array_to_string(array_agg(v.property_id || '_' || v.value_id),' ') AS attrs_text, \
                array_to_string(array_agg(data),' ') AS vals \
            FROM ( \
                SELECT \
                    product_id, \
                    property_id, \
                    value_id \
                FROM p \
                join product.product_to_value using(product_id) \
                where property_id != 2188 \
            UNION \
                SELECT \
                    pv1.product_id, \
                    148, \
                    pv1.value_id \
                FROM product.product_to_value pv1 \
                LEFT JOIN product.product_to_value pv2 ON pv2.property_id=148 \
                AND pv2.product_id=pv1.product_id \
                WHERE pv1.property_id=147 \
                AND pv2.value_id IS NULL \
            ) AS pv \
            JOIN product.value as v USING(value_id) \
            GROUP BY product_id \
            ), \
          min_delivery_aggregated as ( \
              SELECT \
                pmdd.product_id, \
                tz.shop_id, \
                min(date) as min_delivery_date, \
                array_to_string( \
                    array_append( \
                      array_agg((to_char(pmdd.date, 'YYYYMMDD') || pmdd.delivery_id)::BIGINT), \
                      min(to_char(pmdd.date, 'YYYYMMDD')::BIGINT) \
                    ), \
                    ',' \
                ) as min_delivery_dates \
              FROM product.product_min_delivery_date as pmdd \
              JOIN transport.delivery as td ON pmdd.delivery_id = td.delivery_id \
              JOIN transport.zone as tz ON td.zone_id = tz.zone_id \
              WHERE date >= current_date \
              GROUP BY pmdd.product_id, tz.shop_id \
            ), \
        pre_sort AS ( \
            SELECT p2css.product_id, \
                   pa.shop_id, \
                   p2css.category_site_id, \
                   ROW_NUMBER() \
                           OVER (PARTITION BY pa.shop_id, \
                               p2css.category_site_id \
                               ORDER BY cssg.sort ASC, p2css.sort ASC ) AS sort_index, \
                   (CASE \
                        WHEN cssg."limit" IS NULL OR cssg."limit" >= (ROW_NUMBER() \
                                OVER (PARTITION BY pa.shop_id, \
                                                   p2css.category_site_id, \
                                                   p2css.category_site_sort_group_id \
                                      ORDER BY cssg.sort ASC, p2css.sort ASC )) \
                            THEN TRUE \
                        ELSE FALSE END) AS is_suitable \
            FROM product.product_to_category_site_sort p2css \
            JOIN product.category_site_sort_group cssg \
                 ON p2css.category_site_sort_group_id = cssg.category_site_sort_group_id \
            JOIN product.product_activity pa ON p2css.product_id = pa.product_id \
            WHERE NOW() BETWEEN p2css.start_at AND p2css.end_at \
                OR (p2css.start_at IS NULL AND p2css.end_at IS NULL) \
            AND pa.is_active = true \
            ORDER BY pa.shop_id ASC, p2css.category_site_id ASC, cssg.sort ASC, p2css.sort ASC \
        ), \
        aggr_sort AS ( \
            SELECT ps.product_id, \
                   ps.shop_id, \
                   ps.category_site_id, \
                   row_number() OVER \
                       (PARTITION BY ps.shop_id, ps.category_site_id \
                        ORDER BY ps.shop_id ASC, ps.category_site_id ASC, MIN(ps.sort_index) ASC \
                       ) \
                       AS sort \
            FROM pre_sort AS ps \
            WHERE ps.is_suitable = TRUE \
            GROUP BY ps.product_id, ps.shop_id, ps.category_site_id \
        ), \
        full_sort as ( \
            select \
            aggs.product_id, \
            aggs.shop_id, \
            json_object_agg(aggs.category_site_id, aggs.sort) AS sort \
            from aggr_sort as aggs \
            group by aggs.product_id, aggs.shop_id \
        ), \
        quantum_rule as ( \
            select \
                pqr.quantum_rule_id, \
                pqr.product_id, \
                pqr.quantum_discount, \
                pqr.quantum_price, \
                pqr.packaging_quantum, \
                json_array_elements(pqr.region_ids::json)::text::int as quantum_region_id \
            from promo.quantum_rule as pqr \
                join product.product as pp on pqr.product_id = pp.product_id AND pqr.deleted_at IS NULL \
                                                    AND (pqr.start_at < now() OR pqr.start_at is null) \
                                                    AND (pqr.end_at > now() OR pqr.end_at is null) \
        ), \
        shop_prices as ( \
            select \
                price.*, \
                case \
                   when \
                               price.current_old_price > 0 \
                           and price.current_old_price > price.current_price \
                           and price.current_old_price - price.current_price >= 5 \
                           and ((price.current_old_price - price.current_price) / price.current_old_price) > 0.1 \
                       then \
                       case \
                           when product.is_fractional = true \
                               then round(price.current_old_price * product.pre_price_ratio, 2) \
                           else price.current_old_price end \
                   else 0 \
                end as ratio_old_price, \
                product.is_packaging_sale, \
                product.quantum_discount, \
                product.packing_quantum, \
                quantum_rule.quantum_discount as quantum_rule_discount, \
                quantum_rule.quantum_price as quantume_rule_price, \
                quantum_rule.packaging_quantum as packing_quantum_rule \
            from product.price_shop price \
                inner join product.product product ON price.product_id = product.product_id \
                left join setting.shop ss on price.shop_id = ss.shop_id \
                left join quantum_rule ON price.product_id = quantum_rule.product_id AND quantum_rule.quantum_region_id = ss.region_id \
            where price.current_price > 0 \
        ), \
        prices as ( \
            select \
                price.*, \
                case when \
                   price.current_old_price > 0 \
                   and price.current_old_price > price.current_price \
                   and price.current_old_price - price.current_price >= 5 \
                   and ((price.current_old_price - price.current_price) / price.current_old_price) > 0.1 \
                then \
                   case when product.is_fractional = true then round(price.current_old_price * product.pre_price_ratio, 2) else price.current_old_price end \
                else 0 \
                end as ratio_old_price, \
                product.is_packaging_sale, \
                product.quantum_discount, \
                product.packing_quantum, \
                quantum_rule.quantum_discount as quantum_rule_discount, \
                quantum_rule.quantum_price as quantum_rule_price, \
                quantum_rule.packaging_quantum as packing_quantum_rule \
            from product.price price \
            inner join product.product product ON price.product_id = product.product_id \
            left join quantum_rule ON price.product_id = quantum_rule.product_id AND quantum_rule.quantum_region_id = price.region_id \
            where price.current_price > 0 \
        ), \
        discounts as ( \
            select \
                price.product_id, \
                price.region_id, \
                case when price.ratio_old_price = 0 \
                then price.quantum_discount \
                else \
                    case when \
                        price.is_packaging_sale = true \
                        and \
                            round((price.ratio_old_price - price.current_price)/price.ratio_old_price * 100, 2) < \
                            round(((price.ratio_old_price * price.packing_quantum) - (price.quantum_price * price.packing_quantum))/(price.ratio_old_price * price.packing_quantum) * 100, 2) \
                    then \
                        round(((price.ratio_old_price * price.packing_quantum) - (price.quantum_price * price.packing_quantum))/(price.ratio_old_price * price.packing_quantum) * 100, 2) \
                    else \
                        round((price.ratio_old_price - price.current_price)/price.ratio_old_price * 100, 2) \
                    end \
                end as discount \
            from prices as price \
        ), \
        shop_discounts as ( \
            select \
                price.product_id, \
                price.shop_id, \
                case when price.ratio_old_price = 0 \
                then price.quantum_discount \
                else \
                    case when \
                        price.is_packaging_sale = true \
                        and \
                            round((price.ratio_old_price - price.current_price)/price.ratio_old_price * 100, 2) < \
                            round(((price.ratio_old_price * price.packing_quantum) - (price.quantum_price * price.packing_quantum))/(price.ratio_old_price * price.packing_quantum) * 100, 2) \
                    then \
                        round(((price.ratio_old_price * price.packing_quantum) - (price.quantum_price * price.packing_quantum))/(price.ratio_old_price * price.packing_quantum) * 100, 2) \
                    else \
                        round((price.ratio_old_price - price.current_price)/price.ratio_old_price * 100, 2) \
                    end \
                end as discount \
            from shop_prices as price \
        ), \
        category as ( \
          select \
            distinct on (p.product_id) \
            p.product_id, \
            cs.url, \
            cs.name \
          from p \
            join product.product_to_category_site p2cs on p.product_id = p2cs.product_id \
            join product.category_site cs on p2cs.category_site_id = cs.category_site_id \
          order by p.product_id, p2cs.is_primary desc, cs.category_site_id \
        ), \
        product_file_desktop as ( \
            select ptf.product_id, \
                   f.file_id, \
                   f.ext, \
                   f.url, \
                   f.name \
            from product.product_to_file ptf \
                     join product.file f on ptf.file_id = f.file_id \
            where ptf.deleted_at is null \
              and f.layout = 3 \
              and f.file_type_id = 10 \
              and f.active_for_site = true \
            order by ptf.sort asc \
        ), \
        product_file_mobile as ( \
            select ptf.product_id, \
                   f.file_id, \
                   f.ext, \
                   f.url, \
                   f.name \
            from product.product_to_file ptf \
                     join product.file f on ptf.file_id = f.file_id \
            where ptf.deleted_at is null \
              and f.file_type_id = 10 \
              and f.active_for_site = true \
            order by ptf.sort asc, f.layout asc \
        ), \
        clubs as ( \
            select ctp.product_id, json_object_agg(c.name, c.rate) AS clubs \
            from promo.club_to_product ctp \
                join promo.club c on ctp.club_id = c.club_id and c.is_active = true \
            group by ctp.product_id \
        ), \
        badge as ( \
            select distinct \
                pptp.product_id, \
                b.icon_upload_id as upload_id, \
                u.ext as ext, \
                u.url as upload_url, \
                b.name, \
                b.description, \
                b.url, \
                b.badge_id, \
                b.text_mobile, \
                b.color_badge_mobile as mobile_color, \
                pptp.promo_id \
            from promo.pre_promo_to_product pptp \
                join promo.promo pp on pp.promo_id = pptp.promo_id \
                join promo.badge as b on b.badge_id = pp.badge_id \
                join setting.upload u on u.upload_id = b.icon_upload_id \
            where pp.is_active is true \
                and b.badge_id is not null \
                and now() between pp.start_at and pp.end_at \
                and now() between pp.show_at and pp.hide_at \
        ), \
        ft as ( \
            select \
               p.product_id, \
               v.data as fresh_time \
            from p \
                join product.product_to_value as p2v on p.product_id = p2v.product_id \
                join product.value as v on p2v.value_id = v.value_id \
            where v.property_id = 2088 \
        ) \
        select \
            row_number() OVER() AS id, \
            p.product_id, \
            p.is_alcohol, \
            p.is_adult, \
            p.vetcatrisk, \
            p.category_id, \
            p.category_sap_id, \
            pcs.storing_type_id, \
            sites.sites, \
            dt.delivery_types, \
            pa.is_active, \
            (pa.activity_status != 40) AS show_in_search, \
            pa.activity_status AS activity_status, \
            extract(epoch from pa.updated_at)::INT AS activity_timestamp, \
            mda.min_delivery_date AS min_delivery_date, \
            mda.min_delivery_dates AS min_delivery_date_for_delivery_id, \
            price.region_id, \
            coalesce(shops.shop_id, 0) AS shop_id, \
            coalesce(pps.current_price, price.current_price) AS price, \
            coalesce(CASE WHEN shop_discounts.shop_id = shops.shop_id THEN shop_discounts.discount ELSE discounts.discount END, 0) AS discount, \
            p.file_id, \
            cats.category_site_ids, \
            promos.promo_ids, \
            promos.has_filter_promo_n_plus, \
            coalesce(reviews.rating, 0) AS rate, \
            floor(coalesce(reviews.rating, 0)) AS rate_floor, \
            is_new_badge.start_date AS badgenew, \
            is_new_badge.description AS badge_new_description, \
            is_new_badge.icon_upload_id AS badge_new_icon_id, \
            is_new_badge.url AS badge_new_url, \
            badge.upload_id AS badge_upload_id, \
            badge.url AS badge_url, \
            badge.badge_id AS badge_id, \
            badge.text_mobile as badge_text_mobile, \
            badge.mobile_color as badge_mobile_color, \
            badge.description as badge_description, \
            badge.name as badge_name, \
            badge.ext as badge_ext, \
            badge.upload_url as badge_upload_url, \
            badge.promo_id as badge_promo_id, \
            props.attrs, \
            props.attrs_text, \
            trim(from p.name) as name_and_synonyms, \
            p.pure_name as name, \
            cats.cnames, \
            props.vals, \
            i.description||' '||p.product_id as description, \
            full_sort.sort as sort_by_category, \
            coalesce(aggr_sort.sort, 999999999) as sort, \
            p.plu_type, \
            file.ext as file_ext, \
            file.url as file_url, \
            file_type.code as file_type_code, \
            pfd.file_id as quantum_image_id, \
            pfd.ext as quantum_image_ext, \
            pfd.name as quantum_image_name, \
            pfd.url as quantum_image_url, \
            pfm.file_id as quantum_m_image_id, \
            pfm.ext as quantum_m_image_ext, \
            pfm.name as quantum_m_image_name, \
            pfm.url as quantum_m_image_url, \
            p.is_fractional, \
            p.is_fractional_nominal, \
            p.final_packing_quantum, \
            case when quantum_rule.quantum_rule_id is not null then quantum_rule.packaging_quantum else null end as final_packing_quantum_rule, \
            p.is_packaging_sale, \
            case when quantum_rule.quantum_rule_id is not null then true else false end as is_packaging_sale_quantum_rule, \
            p.pre_quantum, \
            p.translit, \
            p.pre_price_ratio, \
            p.pre_packing_step, \
            p.quantum_discount, \
            CASE WHEN price.rule_old_price > 0 THEN 0 ELSE quantum_rule.quantum_discount END AS quantum_rule_discount, \
            coalesce(pps.current_price, price.current_price) as cur_price, \
            coalesce(pps.current_old_price, price.current_old_price) as cur_old_price, \
            coalesce(pps.quantum_price, price.quantum_price) as cur_quantum_price, \
            CASE WHEN price.rule_old_price > 0 THEN coalesce(pps.current_price, price.current_price) ELSE coalesce(quantum_rule.quantum_price, pps.quantum_price, price.quantum_price) END AS cur_quantum_rule_price, \
            cs.url as category_url, \
            cs.name as category_name, \
            coalesce(reviews.feedbacks,0) as cur_feedbacks, \
            coalesce(reviews.rating,0) as cur_rating, \
            p_trademark.value_id as trademark_id, \
            p_trademark.data as trademark_name, \
            clubs.clubs, \
            ft.fresh_time, \
            coalesce(promos.product_sort_promo, 999999999) as product_sort_promo, \
            p.pre_brand_translit, \
            product_popularity.data as popularity \
        from p \
        join props on p.product_id = props.product_id \
        JOIN product.price AS price on p.product_id = price.product_id \
        join cats on p.product_id = cats.product_id and cats.cats_region_id = price.region_id \
        left join shops on p.product_id = shops.product_id and price.region_id = shops.region_id \
        left join product.price_shop pps on p.product_id = pps.product_id and shops.shop_id = pps.shop_id \
        left join product.product_activity pa on p.product_id = pa.product_id and shops.shop_id = pa.shop_id \
        left join promos on p.product_id = promos.product_id and shops.shop_id = promos.shop_id \
        left join reviews on p.product_id = reviews.product_id \
        left join is_new_badge on p.product_id = is_new_badge.product_id \
        left join discounts on p.product_id = discounts.product_id and price.region_id = discounts.region_id \
        left join shop_discounts on p.product_id = shop_discounts.product_id and shops.shop_id = shop_discounts.shop_id \
        LEFT JOIN product.product_info i on p.product_id = i.product_id \
        LEFT JOIN product.product_lock AS pl on p.product_id = pl.product_id \
        LEFT JOIN min_delivery_aggregated AS mda ON p.product_id = mda.product_id and shops.shop_id = mda.shop_id \
        LEFT JOIN aggr_sort ON p.product_id = aggr_sort.product_id AND shops.shop_id = aggr_sort.shop_id \
        LEFT JOIN full_sort ON p.product_id = full_sort.product_id AND shops.shop_id = full_sort.shop_id \
        LEFT JOIN sites ON p.product_id = sites.product_id \
        LEFT JOIN delivery_types dt ON p.product_id = dt.product_id \
        LEFT JOIN product.category_sap as pcs on pcs.category_sap_id = p.category_sap_id \
        left join product.file file on file.file_id = p.file_id \
        left join product.file_type on file.file_type_id = file_type.file_type_id \
        left join product_file_desktop pfd on p.product_id = pfd.product_id \
        left join product_file_mobile pfm on p.product_id = pfm.product_id \
        left join p_trademark on p_trademark.product_id = p.product_id \
        join category cs on p.product_id = cs.product_id \
        left join clubs on clubs.product_id = p.product_id \
        left join badge on badge.product_id = p.product_id \
        left join ft on p.product_id = ft.product_id \
        left join quantum_rule on p.product_id = quantum_rule.product_id AND quantum_rule.quantum_region_id = price.region_id \
        LEFT JOIN product_popularity ON p.product_id = product_popularity.product_id \
        WHERE ( \
            pl.product_lock_id IS NULL \
            OR ( \
                array_length(pl.shop_id, 1) IS NOT NULL \
                AND NOT (shops.shop_id = ANY(pl.shop_id)) \
            )\
        );


    sql_attr_uint = product_id
    sql_attr_uint = shop_id
    sql_attr_uint = region_id
    sql_attr_uint = storing_type_id
    sql_attr_uint = activity_status
    sql_attr_timestamp = activity_timestamp
    sql_attr_bool = is_alcohol
    sql_attr_bool = is_adult
    sql_attr_bool = is_active
    sql_attr_bool = show_in_search
    sql_attr_string = file_id
    sql_field_string = attrs_text
    sql_attr_float = price
    sql_attr_float = discount
    sql_attr_float = rate
    sql_attr_uint = rate_floor
    sql_attr_timestamp = badgenew
    sql_attr_string = min_delivery_date
    sql_attr_uint = vetcatrisk
    sql_attr_uint = category_sap_id
    sql_attr_uint = category_id
    sql_attr_bool = has_filter_promo_n_plus
    sql_attr_uint = plu_type
    sql_attr_string = name
    sql_attr_string = name_and_synonyms
    sql_attr_string = file_ext
    sql_attr_string = file_url
    sql_attr_string = file_type_code
    sql_attr_string = trademark_name
    sql_attr_string = translit
    sql_attr_string = category_url
    sql_attr_string = category_name
    sql_attr_string = badge_new_url
    sql_attr_string = badge_new_description
    sql_attr_string = badge_url
    sql_attr_string = badge_id
    sql_attr_string = badge_text_mobile
    sql_attr_string = badge_mobile_color
    sql_attr_string = badge_description
    sql_attr_string = badge_name
    sql_attr_string = final_packing_quantum
    sql_attr_string = final_packing_quantum_rule
    sql_attr_string = trademark_id
    sql_attr_string = quantum_image_id
    sql_attr_string = quantum_image_ext
    sql_attr_string = quantum_image_url
    sql_attr_string = quantum_image_name
    sql_attr_string = quantum_m_image_id
    sql_attr_string = quantum_m_image_ext
    sql_attr_string = quantum_m_image_url
    sql_attr_string = quantum_m_image_name
    sql_attr_string = quantum_discount
    sql_attr_string = quantum_rule_discount
    sql_attr_string = cur_feedbacks
    sql_attr_string = badge_new_icon_id
    sql_attr_string = badge_upload_id
    sql_attr_string = fresh_time
    sql_attr_string = badge_upload_url
    sql_attr_string = badge_ext
    sql_attr_string = badge_promo_id
    sql_attr_float = pre_quantum
    sql_attr_float = pre_price_ratio
    sql_attr_float = pre_packing_step
    sql_attr_float = cur_price
    sql_attr_float = cur_old_price
    sql_attr_float = cur_quantum_price
    sql_attr_float = cur_quantum_rule_price
    sql_attr_float = cur_rating
    sql_attr_bool = is_fractional
    sql_attr_bool = is_fractional_nominal
    sql_attr_bool = is_packaging_sale
    sql_attr_bool = is_packaging_sale_quantum_rule
    sql_attr_json = clubs
    sql_attr_multi = uint attrs from field
    sql_attr_multi = bigint min_delivery_date_for_delivery_id from field
    sql_attr_multi = uint category_site_ids from field
    sql_attr_multi = uint sites from field
    sql_attr_multi = uint delivery_types from field
    sql_attr_multi = uint promo_ids from field
    sql_attr_uint = sort
    sql_attr_json = sort_by_category
    sql_attr_uint = product_sort_promo
    sql_attr_string = pre_brand_translit
    sql_attr_json = popularity
}


index products
{
    source			= products
    path			= /var/lib/manticore/data/products
    docinfo			= extern
    mlock			= 0
    morphology		= stem_enru
    min_word_len	= 2
    charset_table	= 0..9, A..Z->a..z, _, a..z, U+410..U+42F->U+430..U+44F, U+430..U+44F, U+0401->U+0435, U+0451->U+0435
    html_strip		= 1
    html_remove_elements = style, script
    wordforms = /var/lib/manticore/data/wordforms.txt
}

source alcohol : dbconnect
{
    sql_query = with p as ( \
            SELECT \
                pp.product_id, \
                pp.is_alcohol, \
                pp.file_id, \
                pp.name || ' ' || \
                COALESCE(string_agg(DISTINCT csk.keyword, ' '), '') ||  ' ' || \
                COALESCE(string_agg(DISTINCT csk.stemm, ' '), '') || ' ' || \
                COALESCE(string_agg(csw.word, ' '), '') AS name \
            FROM product.product AS pp \
            LEFT JOIN content.synonym_to_product cstp ON cstp.product_id = pp.product_id \
            LEFT JOIN content.synonym_keyword csk ON csk.synonym_keyword_id = cstp.synonym_keyword_id AND csk.is_active = TRUE \
            LEFT JOIN content.synonym_word csw ON csw.synonym_keyword_id = csk.synonym_keyword_id \
            WHERE pp.product_status_id IN (4,5,6) \
            AND pp.category_sap_id <> -1 \
            GROUP BY pp.product_id \
        ), \
        cc as ( \
            SELECT \
                category_site_id, \
                unnest(ns_path||category_site_id) AS cat_id \
            FROM product.category_site \
            WHERE deleted_at IS NULL \
        ), \
        shops as ( \
            SELECT \
              DISTINCT ON (ps.product_id, shop.shop_id, shop.region_id) \
              ps.product_id, \
              shop.shop_id, \
              shop.region_id \
            FROM product.shipment AS ps \
              INNER JOIN product.shipment_to_shop as sts on ps.shipment_id = sts.shipment_id \
              INNER JOIN setting.shop AS shop ON sts.shop_id = shop.shop_id \
              INNER JOIN product.product_activity AS pa \
                ON pa.shop_id = shop.shop_id AND pa.region_id = shop.region_id AND pa.product_id = ps.product_id \
            WHERE \
              pa.activity_status != 40 \
        ), \
        cats as ( \
            SELECT \
                product_id, \
                unnest( \
                    case \
                        when array_length(child.region_ids, 1) > 0 \
                        then child.region_ids \
                        else array[reg.region_id] \
                        end \
                ) as cats_region_id, \
                array_to_string(array_agg(DISTINCT cs.name),' ') AS cnames, \
                array_to_string(array_agg(DISTINCT cs.category_site_id),',') AS category_site_ids \
            FROM p \
            JOIN product.product_to_category_site p2cs using(product_id) \
            JOIN cc using(category_site_id) \
            JOIN product.category_site cs ON cs.category_site_id = cat_id \
            JOIN product.category_site as child ON p2cs.category_site_id = child.category_site_id \
            CROSS JOIN setting.region as reg \
            WHERE cc.cat_id != 1 \
            AND cs.deleted_at IS NULL \
            GROUP BY product_id, cats_region_id \
        ), \
        sites AS ( \
           SELECT \
               p.product_id, \
               array_to_string(array_agg(cs.site_id),',') as sites \
           FROM product.product_to_category_site as p \
           INNER JOIN product.category_site_to_site as cs ON cs.category_site_id = p.category_site_id \
           WHERE p.is_primary = true \
           GROUP BY p.product_id \
        ), \
        delivery_types AS ( \
           SELECT \
               ptdt.product_id, \
               array_to_string(array_agg(ptdt.delivery_type_id),',') as delivery_types \
           FROM product.product_to_delivery_type as ptdt \
           GROUP BY ptdt.product_id \
        ), \
        pre_sort AS ( \
            SELECT p2css.product_id, \
                   pa.shop_id, \
                   p2css.category_site_id, \
                   ROW_NUMBER() \
                           OVER (PARTITION BY pa.shop_id, \
                               p2css.category_site_id \
                               ORDER BY cssg.sort ASC, p2css.sort ASC ) AS sort_index, \
                   (CASE \
                        WHEN cssg."limit" IS NULL OR cssg."limit" >= (ROW_NUMBER() \
                                OVER (PARTITION BY pa.shop_id, \
                                                   p2css.category_site_id, \
                                                   p2css.category_site_sort_group_id \
                                      ORDER BY cssg.sort ASC, p2css.sort ASC )) \
                            THEN TRUE \
                        ELSE FALSE END) AS is_suitable \
            FROM product.product_to_category_site_sort p2css \
            JOIN product.category_site_sort_group cssg \
                 ON p2css.category_site_sort_group_id = cssg.category_site_sort_group_id \
            JOIN product.product_activity pa ON p2css.product_id = pa.product_id \
            WHERE NOW() BETWEEN p2css.start_at AND p2css.end_at \
                OR (p2css.start_at IS NULL AND p2css.end_at IS NULL) \
            AND pa.is_active = true \
            ORDER BY pa.shop_id ASC, p2css.category_site_id ASC, cssg.sort ASC, p2css.sort ASC \
        ), \
        aggr_sort AS ( \
            SELECT ps.product_id, \
                   ps.shop_id, \
                   ps.category_site_id, \
                   row_number() OVER \
                       (PARTITION BY ps.shop_id, ps.category_site_id \
                        ORDER BY ps.shop_id ASC, ps.category_site_id ASC, MIN(ps.sort_index) ASC \
                       ) \
                       AS sort \
            FROM pre_sort AS ps \
            WHERE ps.is_suitable = TRUE \
            GROUP BY ps.product_id, ps.shop_id, ps.category_site_id \
        ), \
        full_sort as ( \
            select \
            aggs.product_id, \
            aggs.shop_id, \
            json_object_agg(aggs.category_site_id, aggs.sort) AS sort \
            from aggr_sort as aggs \
            group by aggs.product_id, aggs.shop_id \
        ), \
        promos as ( \
            select \
                product_id, \
                region_id, \
                array_to_string(array_agg(promo_id),',') as promo_ids \
            from ( \
                SELECT \
                    product_id, \
                    region_id, \
                    unnest(ARRAY[promo_id,parent_promo_id]) AS promo_id \
                FROM promo.pre_promo_to_product pp2p \
                JOIN promo.promo USING(promo_id) \
                WHERE pp2p.is_gift=FALSE \
                AND promo.is_active=TRUE \
            ) as ttt \
            where promo_id > 0 \
            group by product_id,region_id \
        ), \
        reviews as ( \
            SELECT \
                product_id, \
                round(sum(rating) / count(1),2) AS rating \
            FROM product.product_to_review \
            JOIN content.review USING(review_id) \
            WHERE content.review.review_status_id = '5' \
            GROUP BY product_id \
        ), \
        is_new_badge AS ( \
            SELECT btp.product_id, \
                   btp.start_date \
            FROM product.badge_to_product as btp \
            WHERE badge_id = 1 \
        ), \
        props as ( \
            SELECT \
                product_id, \
                array_to_string(array_agg(v.value_id), ',') AS attrs, \
                array_to_string(array_agg(v.property_id || '_' || v.value_id),' ') AS attrs_text, \
                array_to_string(array_agg(data),' ') AS vals \
            FROM ( \
                SELECT \
                    product_id, \
                    property_id, \
                    value_id \
                FROM p \
                join product.product_to_value using(product_id) \
                where property_id != 2188 \
            UNION \
                SELECT \
                    pv1.product_id, \
                    148, \
                    pv1.value_id \
                FROM product.product_to_value pv1 \
                LEFT JOIN product.product_to_value pv2 ON pv2.property_id=148 \
                AND pv2.product_id=pv1.product_id \
                WHERE pv1.property_id=147 \
                AND pv2.value_id IS NULL \
            ) AS pv \
            JOIN product.value as v USING(value_id) \
            GROUP BY product_id \
            ), \
          min_delivery_aggregated as ( \
              SELECT \
                pmdd.product_id, \
                tz.shop_id, \
                array_to_string( \
                    array_append( \
                      array_agg((to_char(pmdd.date, 'YYYYMMDD') || pmdd.delivery_id)::BIGINT), \
                      min(to_char(pmdd.date, 'YYYYMMDD')::BIGINT) \
                    ), \
                    ',' \
                ) as min_delivery_date \
              FROM product.product_min_delivery_date as pmdd \
              JOIN transport.delivery as td ON pmdd.delivery_id = td.delivery_id \
              JOIN transport.zone as tz ON td.zone_id = tz.zone_id \
              GROUP BY pmdd.product_id, tz.shop_id \
            ) \
        select \
            row_number() OVER() AS id, \
            p.product_id, \
            pa.is_active, \
            p.is_alcohol, \
            (pa.activity_status != 40) AS show_in_search, \
            pa.activity_status AS activity_status, \
            extract(epoch from pa.updated_at)::INT AS activity_timestamp, \
            pa.min_delivery_date AS min_delivery_date, \
            mda.min_delivery_date AS min_delivery_date_for_delivery_id, \
            price.region_id, \
            coalesce(shops.shop_id, 0) AS shop_id, \
            coalesce(CASE WHEN price.rule_price > 0 THEN price.rule_price ELSE price.price END, 0) AS price, \
            p.file_id, \
            cats.category_site_ids, \
            sites.sites, \
            dt.delivery_types, \
            promos.promo_ids, \
            coalesce(reviews.rating, 0) AS rate, \
            floor(coalesce(reviews.rating, 0)) AS rate_floor, \
            is_new_badge.start_date AS badgenew, \
            props.attrs, \
            props.attrs_text, \
            p.name, \
            cats.cnames, \
            coalesce(aggr_sort.sort, 999999999) as sort, \
            full_sort.sort as sort_by_category, \
            props.vals, \
            i.description||' '||p.product_id as description \
        from p \
        join props on p.product_id = props.product_id \
        JOIN product.price AS price on p.product_id = price.product_id \
        join cats on p.product_id = cats.product_id and cats.cats_region_id = price.region_id \
        left join shops on p.product_id = shops.product_id and price.region_id = shops.region_id \
        left join aggr_sort on p.product_id = aggr_sort.product_id AND aggr_sort.shop_id = shops.shop_id \
        LEFT JOIN full_sort ON p.product_id = full_sort.product_id AND shops.shop_id = full_sort.shop_id \
        left join product.product_activity pa on p.product_id = pa.product_id and shops.shop_id = pa.shop_id \
        left join promos on p.product_id = promos.product_id and price.region_id = promos.region_id \
        left join reviews on p.product_id = reviews.product_id \
        left join is_new_badge on p.product_id = is_new_badge.product_id \
        LEFT JOIN product.product_info i on p.product_id = i.product_id \
        LEFT JOIN product.product_lock AS pl on p.product_id = pl.product_id \
        LEFT JOIN sites ON p.product_id = sites.product_id \
        LEFT JOIN delivery_types dt ON p.product_id = dt.product_id \
        LEFT JOIN min_delivery_aggregated AS mda ON p.product_id = mda.product_id and shops.shop_id = mda.shop_id \
        WHERE ( \
            pl.product_lock_id IS NULL \
            OR ( \
                array_length(pl.shop_id, 1) IS NOT NULL \
                AND NOT (shops.shop_id = ANY(pl.shop_id)) \
            ) \
            OR (p.is_alcohol = true AND (price.price > 0 OR price.rule_price > 0)) \
        );
        sql_attr_uint = product_id
    sql_attr_uint = shop_id
    sql_attr_uint = region_id
    sql_attr_uint = activity_status
    sql_attr_timestamp = activity_timestamp
    sql_attr_bool = is_active
    sql_attr_bool = is_alcohol
    sql_attr_bool = show_in_search
    sql_attr_string = file_id
    sql_field_string = attrs_text
    sql_attr_float = price
    sql_attr_float = rate
    sql_attr_uint = rate_floor
    sql_attr_timestamp = badgenew
    sql_attr_string = min_delivery_date
    sql_attr_uint = sort
    sql_attr_json = sort_by_category
    sql_attr_multi = uint attrs from field
    sql_attr_multi = bigint min_delivery_date_for_delivery_id from field
    sql_attr_multi = uint category_site_ids from field
    sql_attr_multi = uint sites from field
    sql_attr_multi = uint delivery_types from field
    sql_attr_multi = uint promo_ids from field

}

index alcohol
{
    source			= alcohol
    path			= /var/lib/manticore/data/alcohol
    docinfo			= extern
    mlock			= 0
    morphology		= stem_enru
    min_word_len	= 2
    charset_table	= 0..9, A..Z->a..z, _, a..z, U+410..U+42F->U+430..U+44F, U+430..U+44F, U+0401->U+0435, U+0451->U+0435
    html_strip		= 1
    html_remove_elements = style, script
    wordforms = /var/lib/manticore/data/wordforms.txt
}

source static : dbconnect
{
    sql_query = with rs as ( \
                        select \
                                recipe_id, \
                                array_to_string(array_agg(text),' ') as steps \
                        from content.recipe_step \
                        group by recipe_id \
                ), \
                rc as ( \
                        select \
                                recipe_id, \
                                array_to_string(array_agg(name),' ') as comps \
                        from content.recipe_to_component \
                        join content.component using(component_id) \
                        group by recipe_id \
                ) \
                select \
                        * \
                from ( \
                        select \
                                2000000+news_id as index, \
                                news_id as entity_id, \
                                'news' as entity, \
                                name, \
                                text \
                        from content.news \
                        where is_active=true \
                union all \
                        select \
                                1000000+page_id as index, \
                                page_id as entity_id, \
                                'page' as entity, \
                                name, \
                                body \
                        from content.page \
                        where is_active=true \
                        and redirect = '' \
                union all \
                        select \
                                3000000+recipe_id as index, \
                                recipe_id as entity_id, \
                                'recipe' as entity, \
                                name, \
                                text||' '||steps||' '||comps as text \
                        from content.recipe \
                        left join rs using(recipe_id) \
                        left join rc using(recipe_id) \
                        where is_active=true \
                ) as d;
    
        sql_attr_uint = entity_id
    sql_attr_string = entity
    sql_attr_multi = uint region_id from query; select \
                1000000+page_id as index, \
                region_id \
        from content.page_to_region \
        union all \
        select \
                2000000+news_id as index, \
                region_id \
        from content.news_to_region \
        union all \
        select \
                3000000+recipe_id as index, \
                region_id \
        from setting.region,content.recipe;

}
source fias_city_index : dbconnect
{
sql_query = SELECT \
                      row_number() \
                      OVER ()                                   AS index, \
                      fa.aoid, \
                      fa.aoguid, \
                      fa.parentguid, \
                      fa.regioncode, \
                      fa.regioncode as regioncode_uint, \
                      case when fa.aolevel=65 then 6 else fa.aolevel end as aolevel, \
                      lower(fa.formalname)                      AS text, \
                      lower(fa.formalname)                      AS text_str, \
                      fa.formalname, \
                      fa.offname, \
                      fa.shortname, \
                      get_trigram(fa.formalname)                AS trig1, \
                      get_trigram(change_locale(fa.formalname)) AS trig2, \
                      fa2.aoguid                                AS region_guid, \
                      fa2.formalname || ' ' || fa2.shortname    AS region_name, \
                      rf.region_id, \
                      r.region_type_id \
                    FROM setting.fias_addrobj AS fa \
                      JOIN setting.fias_addrobj fa2 ON fa2.code = TO_CHAR(fa.regioncode::int, 'fm00') || '00000000000' \
                      LEFT JOIN setting.region_to_fias_addrobj rf ON rf.aoguid = fa2.aoguid \
                      LEFT JOIN setting.region r ON rf.region_id = r.region_id \
                    WHERE ( \
                          ( \
                              fa.aolevel IN (4, 5, 6, 90) and fa.shortname not in ('гск','тер') \
                          ) OR ( \
                              fa.aolevel = 1 AND fa.shortname = 'г' \
                          ) \
                      ) \
                      AND fa.livestatus = 1 \
                      AND fa.currstatus = 0;
    sql_attr_string = aoid
    sql_attr_string = aoguid
    sql_attr_string = parentguid
    sql_attr_string = regioncode
    sql_attr_uint = regioncode_uint
    sql_attr_string = text
    sql_attr_string = formalname
    sql_attr_string = offname
    sql_attr_string = shortname
    sql_attr_string = region_guid
    sql_attr_string = region_name
    sql_attr_string = region_id
    sql_attr_string = region_type_id
    sql_attr_uint   = aolevel
}

index fias_city_index
{
    source			= fias_city_index
    path			= /var/lib/manticore/data/fias_city_index
    docinfo			= extern
    mlock			= 0
    morphology		= stem_enru
    min_word_len	= 2
    charset_table	= 0..9, A..Z->a..z, _, a..z, U+410..U+42F->U+430..U+44F, U+430..U+44F, U+0401->U+0435, U+0451->U+0435
    html_strip		= 1
    html_remove_elements = style, script
}

source fias_street_index : dbconnect
{
	sql_query = SELECT \
                    row_number() over() as index, \
                    fa.aoid, \
                    fa.aoguid, \
                    fa.parentguid, \
                    fa.regioncode, \
                    lower(fa.offname) as text, \
                    lower(fa.offname) as text_str, \
                    fa.formalname, \
                    fa.offname, \
                    fa.shortname, \
                    get_trigram(fa.offname) as trig1, \
                    get_trigram(change_locale(fa.offname)) as trig2 \
                FROM setting.fias_addrobj as fa \
                WHERE \
                    fa.aolevel IN (7,91,65) \
                    AND fa.livestatus = 1 \
                    AND fa.currstatus = 0;
	
	    sql_attr_string = aoid
    sql_attr_string = aoguid
    sql_attr_string = regioncode
    sql_attr_string = parentguid
    sql_attr_string = text
    sql_attr_string = formalname
    sql_attr_string = offname
    sql_attr_string = shortname


}

index fias_street_index
{
	source			= fias_street_index
	path			= /var/lib/manticore/data/fias_street_index
    docinfo			= extern
    mlock			= 0
    morphology		= stem_enru
    min_word_len	= 2
    charset_table	= 0..9, A..Z->a..z, _, a..z, U+410..U+42F->U+430..U+44F, U+430..U+44F, U+0401->U+0435, U+0451->U+0435
    html_strip		= 1
    html_remove_elements = style, script
}

source fias_index : dbconnect
{
     sql_query = with t as ( \
                    select regioncode \
                    from setting.region r \
                    join setting.region_to_fias_addrobj using(region_id) \
                    join setting.fias_addrobj using(aoguid) \
                    where r.region_type_id IN (1,2) \
                ), \
                ff as ( \
                    select \
                        aoguid, \
                        case \
                            when offname='Московская' then 'МО' \
                            else trim(shortname,'.')||'. '||offname \
                        end as name, \
                        parentguid, \
                        parentguid as parentguid_str, \
                        aolevel, \
                        regioncode \
                    from t \
                    join setting.fias_addrobj fa using(regioncode) \
                ), \
                lst as ( \
                    select \
                        ff.*, \
                        array_to_string(fias(null,ff.aoguid),', ') as path \
                    from ff \
                    left join ff as ff2 on ff2.parentguid=ff.aoguid \
                    where ff.aolevel != 4 \
                    and ff2.aoguid is null \
                ) \
                select \
                    row_number() over() as index, \
                    lst.*, \
                    lower(lst.name) as name_str, \
                    lower(translate(path,'.,-','')) as path_str, \
                    fa2.aoguid as region_aoguid, \
                    region_id, \
                    get_trigram(translate(path,'.,-','')) as trig1, \
                    get_trigram(change_locale(translate(path,'.,-',''))) as trig2, \
                    array_upper(string_to_array(path,','),1) as path_len, \
                    length(path) as name_len \
                from lst \
                JOIN setting.fias_addrobj fa2 ON fa2.code = TO_CHAR(lst.regioncode::int, 'fm00') || '00000000000' \
                LEFT JOIN setting.region_to_fias_addrobj rf ON rf.aoguid = fa2.aoguid;

         sql_attr_string = aoguid
    sql_attr_string = parentguid
    sql_attr_string = region_aoguid
    sql_attr_string = parentguid_str
    sql_attr_string = name
    sql_attr_string = path
    sql_attr_uint   = region_id
    sql_attr_uint   = name_len
    sql_attr_uint   = path_len

}

index fias_index
{
	source			= fias_index
	path			= /var/lib/manticore/data/fias_index
    docinfo			= extern
    mlock			= 0
    morphology		= stem_enru
    min_word_len	= 2
    charset_table	= 0..9, A..Z->a..z, _, a..z, U+410..U+42F->U+430..U+44F, U+430..U+44F, U+0401->U+0435, U+0451->U+0435
    html_strip		= 1
    html_remove_elements = style, script
}

source address : dbconnect
{
     sql_query = WITH fias AS ( \
                  	SELECT \
                  		array_remove(array[ \
                  			lv5.aoid,lv4.aoid,lv3.aoid, \
                  			lv2.aoid,lv1.aoid \
                  		], NULL) AS aoids_array, \
                  		array_remove(array[ \
                  			lv5.aoguid,lv4.aoguid,lv3.aoguid, \
                  			lv2.aoguid,lv1.aoguid \
                  		], NULL) AS aoguids_array, \
                  		array_remove(array[ \
                  			lv5.shortname,lv5_s.synonym,lv5.formalname,lv5.offname, \
                  			lv4.shortname,lv4_s.synonym,lv4.formalname,lv4.offname, \
                  			lv3.shortname,lv3_s.synonym,lv3.formalname,lv3.offname, \
                  			lv2.shortname,lv2_s.synonym,lv2.formalname,lv2.offname, \
                  			lv1.shortname,lv1_s.synonym,lv1.formalname,lv1.offname \
                  		], NULL) AS full_name_array, \
                  		array_remove(array[ \
                             lv5.formalname,lv4.formalname, \
                             lv3.formalname,lv2.formalname, \
                             lv1.formalname \
                         ], NULL) AS formal_name_array,\
                         array[lv1.shortname,lv1_s.synonym,lv1.formalname] as street_name_array\
                  	FROM setting.fias_addrobj lv1 \
                  		LEFT JOIN setting.address_synonym lv1_s ON lv1_s.shortname = lv1.shortname \
                  		LEFT JOIN setting.fias_addrobj lv2 ON lv2.aoguid = lv1.parentguid AND lv2.livestatus = 1 AND lv2.currstatus = 0 \
                  		LEFT JOIN setting.address_synonym lv2_s ON lv2_s.shortname = lv2.shortname \
                  		LEFT JOIN setting.fias_addrobj lv3 ON lv3.aoguid = lv2.parentguid AND lv3.livestatus = 1 AND lv3.currstatus = 0 \
                  		LEFT JOIN setting.address_synonym lv3_s ON lv3_s.shortname = lv3.shortname \
                  		LEFT JOIN setting.fias_addrobj lv4 ON lv4.aoguid = lv3.parentguid AND lv4.livestatus = 1 AND lv4.currstatus = 0 \
                  		LEFT JOIN setting.address_synonym lv4_s ON lv4_s.shortname = lv4.shortname \
                  		LEFT JOIN setting.fias_addrobj lv5 ON lv5.aoguid = lv4.parentguid AND lv5.livestatus = 1 AND lv5.currstatus = 0 \
                  		LEFT JOIN setting.address_synonym lv5_s ON lv5_s.shortname = lv5.shortname \
                  	WHERE \
                  		lv1.livestatus = 1 AND \
                  		lv1.currstatus = 0 AND \
                  		lv1.aolevel = 7 AND \
                  		array_remove(array[ \
                  			lv5.aoguid,lv4.aoguid,lv3.aoguid, \
                  			lv2.aoguid,lv1.aoguid \
                  		], NULL) && ( \
                  			SELECT array_agg(aoguid) \
                  			FROM setting.region_to_fias_addrobj rtfa \
                  			INNER JOIN setting.region r ON r.region_id = rtfa.region_id AND r.is_active = TRUE AND r.region_type_id IN (1, 4) \
                  		) \
                  ) \
                  SELECT \
                    row_number() over() AS index, \
                    array_to_string(aoids_array, ',') AS aoids_field, \
                    array_to_string(aoguids_array, ',') AS aoguids_field, \
                    replace(array_to_string(full_name_array, ' '), 'N', '') AS full_name_field, \
                    length(replace(array_to_string(full_name_array, ' '), 'N', '')) AS full_name_length, \
                    replace(array_to_string(street_name_array, ' '), 'N', '') AS street_name_field, \
                    get_trigram(array_to_string(full_name_array, ' ')) AS formal_name_trigram_field, \
                    json_build_object('aoids', aoids_array, 'aoguids', aoguids_array) AS feature_json,\
                    extract(epoch from now() at time zone 'utc') AS updated_at \
                  FROM fias\

         sql_field_string = aoids_field
    sql_field_string = aoguids_field
    sql_field_string = full_name_field
    sql_attr_uint = full_name_length
    sql_field_string = street_name_field
    sql_field_string = formal_name_trigram_field
    sql_attr_json = feature_json
    sql_attr_timestamp = updated_at

}

index address
{
	source			= address
	path			= /var/lib/manticore/data/address
    docinfo			= extern
    mlock			= 0
    morphology		= stem_enru
    min_word_len	= 1

    # Ёё в е: U+0401->U+0435, U+0451->U+0435
    # В нижний регистр: U+410..U+42F->U+430..U+44F
    charset_table	= 0..9, A..Z->a..z, _, a..z, U+410..U+42F->U+430..U+44F, U+430..U+44F, U+0401->U+0435, U+0451->U+0435
    blend_chars     = +, -, &, /, U+0023
    ignore_chars    = U+00AD
    index_exact_words = 1
    min_infix_len   = 1
    html_strip      = 1
    html_remove_elements = style, script

}

source prompt : dbconnect
{
	sql_query = SELECT \
                	row_number() over() as index, \
                	entity_id, \
                	object_id, \
                	shop_id, \
                	text, \
                	text as text_str, \
                	text_full, \
                	get_trigram(text) as trig1, \
                	get_trigram(change_locale(text)) as trig2, \
                	url \
                FROM \
                ( \
                	( \
                		SELECT \
                			DISTINCT ON (p.product_id) \
                			6 as entity_id, \
                			p.product_id as object_id, \
                			pa.shop_id as shop_id, \
                			lower(p.name) as text, \
                			p.name as text_full, \
                			'/catalog' || cs.url || '/' || p.translit || '--' || product_id as url \
                		FROM product.product p \
                		INNER JOIN product.product_to_category_site as ptc USING (product_id) \
                		INNER JOIN product.category_site as cs USING (category_site_id) \
                		INNER JOIN product.product_activity as pa USING (product_id) \
                		WHERE \
                		    pa.is_active = TRUE \
                	) \
                	UNION ALL \
                	( \
                		SELECT \
                			9 as entity_id, \
                			NULL as object_id, \
                			NULL as shop_id, \
                			lower(cs.name) as text, \
                			cs.name as text_full, \
                			'/catalog' || cs.url as url \
                		FROM product.category_site as cs \
                		WHERE \
                			cs.deleted_at IS NULL \
                			AND (cs.ns_right - cs.ns_left) = 1 \
                			AND cs.is_hidden = false \
                			AND cs.redirect_url = '' \
                			AND cs.cnt > 0 \
                	) \
                	UNION ALL \
                	( \
                		SELECT \
                			10 as entity_id, \
                			NULL as object_id, \
                			pa.shop_id as shop_id, \
                			lower(cs.name || ' ' || v.data) as text, \
                			cs.name || ' ' || v.data as text_full, \
                			'/catalog' || cs.url || '/brand/' || v.translit as url \
                		FROM product.category_site as cs \
                		INNER JOIN product.product_to_category_site as p2c USING (category_site_id) \
                		INNER JOIN product.product as p USING (product_id) \
                		INNER JOIN product.product_activity as pa USING (product_id) \
                		INNER JOIN product.product_to_value as p2v USING (product_id) \
                		INNER JOIN product.value as v USING (value_id) \
                		WHERE \
                			cs.deleted_at IS NULL \
                			AND (cs.ns_right - cs.ns_left) = 1 \
                			AND cs.is_hidden = false \
                			AND cs.redirect_url = '' \
                			AND cs.cnt > 0 \
                			AND v.property_id IN (147,148) \
                			AND pa.is_active = TRUE \
                		GROUP BY cs.category_site_id, v.value_id, pa.shop_id \
                	) \
                	UNION ALL \
                	( \
                		SELECT \
                			11 as entity_id, \
                			b.brand_id as object_id, \
                			NULL as shop_id, \
                			lower(p.text) as text, \
                			b.name as text_full, \
                			b.url as url \
                		FROM search.brand as b \
                		INNER JOIN search.phrase_to_brand as p2b USING (brand_id) \
                		INNER JOIN search.phrase as p USING (phrase_id) \
                		WHERE \
                			b.is_active = true \
                			AND b.url != '' \
                			AND p.is_blocked = false \
                	) \
                ) w;

	    sql_attr_uint = shop_id
    sql_attr_uint = entity_id
    sql_attr_uint = object_id
    sql_attr_string = text
    sql_attr_string = text_full
    sql_attr_string = url

}

index prompt
{
	source			= prompt
	path			= /var/lib/manticore/data/prompt
	docinfo			= extern
	mlock			= 0
	morphology		= stem_enru
	min_word_len	= 2
	min_infix_len	= 3
	charset_table	= 0..9, A..Z->a..z, _, a..z, U+410..U+42F->U+430..U+44F, U+430..U+44F, U+0401->U+0435, U+0451->U+0435
	html_strip		= 1
	html_remove_elements = style, script
}

source recipes : dbconnect
{
    sql_query = WITH cuisine AS ( \
                    SELECT \
                        r2ct.recipe_id, \
                        array_to_string(array_agg(ct.cuisine_type_id), ',') AS cuisine_type \
                    FROM content.recipe_to_cuisine_type AS r2ct \
                    JOIN content.cuisine_type AS ct USING(cuisine_type_id) \
                    GROUP BY recipe_id \
                ), \
                purpose AS ( \
                    SELECT \
                        r2rp.recipe_id, \
                        array_to_string(array_agg(rp.recipe_purpose_id), ',') AS recipe_purpose \
                    FROM content.recipe_to_recipe_purpose AS r2rp \
                    JOIN content.recipe_purpose AS rp USING (recipe_purpose_id) \
                    GROUP BY recipe_id \
                ), \
                taste AS ( \
                    SELECT \
                        r2t.recipe_id, \
                        array_to_string(array_agg(taste.taste_id), ',') AS taste \
                    FROM content.recipe_to_taste AS r2t \
                    JOIN content.taste AS taste USING (taste_id) \
                    GROUP BY recipe_id \
                ), \
                component AS ( \
                    SELECT \
                        r2ct.recipe_id, \
                        array_to_string(array_agg(ct.component_type_id), ',') AS component_type \
                    FROM content.recipe_to_component_type AS r2ct \
                    JOIN content.component_type AS ct USING (component_type_id) \
                    GROUP BY recipe_id \
                ) \
                SELECT \
                    row_number() OVER() AS id, \
                    r.recipe_id, \
                    r.name, \
                    r.description, \
                    r.text, \
                    r.is_active, \
                    r.is_alcohol, \
                    COALESCE(CASE WHEN r.is_active THEN r.is_active ELSE r.is_alcohol END, false) AS alcohol_condition, \
                    r.is_seller, \
                    extract(epoch FROM r.created_at)::INT AS created_at, \
                    rc.recipe_category_id, \
                    cuisine.cuisine_type, \
                    purpose.recipe_purpose, \
                    r.complexity, \
                    r.alcohol_volume, \
                    r.temperature, \
                    taste.taste, \
                    component.component_type \
                FROM \
                    content.recipe AS r \
                LEFT JOIN content.recipe_category as rc USING(recipe_category_id) \
                LEFT JOIN cuisine USING(recipe_id) \
                LEFT JOIN purpose USING(recipe_id) \
                LEFT JOIN taste USING(recipe_id) \
                LEFT JOIN component USING(recipe_id) \
                WHERE r.is_active = true \
                OR r.is_alcohol = true;
    
        sql_attr_uint = recipe_id
    sql_field_string = name
    sql_field_string = description
    sql_field_string = text
    sql_attr_timestamp = created_at
    sql_attr_bool = is_active
    sql_attr_bool = is_alcohol
    sql_attr_bool = alcohol_condition
    sql_attr_bool = is_seller
    sql_attr_uint = recipe_category_id
    sql_attr_uint = complexity
    sql_attr_uint = alcohol_volume
    sql_attr_uint = temperature
    sql_attr_multi = uint cuisine_type from field
    sql_attr_multi = uint recipe_purpose from field
    sql_attr_multi = uint taste from field
    sql_attr_multi = uint component_type from field
}

index recipes
{
    source			= recipes
    path			= /var/lib/manticore/data/recipes
    docinfo			= extern
    mlock			= 0
    morphology		= stem_enru
    min_word_len	= 2
    charset_table	= 0..9, A..Z->a..z, _, a..z, U+410..U+42F->U+430..U+44F, U+430..U+44F, U+0401->U+0435, U+0451->U+0435
    html_strip		= 1
    html_remove_elements = style, script
    wordforms = /var/lib/manticore/data/wordforms.txt
}


#############################################################################
## indexer settings
#############################################################################

indexer
{
	# memory limit, in bytes, kiloytes (16384K) or megabytes (256M)
	# optional, default is 128M, max is 2047M, recommended is 256M to 1024M
	mem_limit		= 1024M

	# maximum IO calls per second (for I/O throttling)
	# optional, default is 0 (unlimited)
	#
	

	# maximum IO call size, bytes (for I/O throttling)
	# optional, default is 0 (unlimited)
	#
	

	# maximum xmlpipe2 field length, bytes
	# optional, default is 2M
	#
	

	# write buffer size, bytes
	# several (currently up to 4) buffers will be allocated
	# write buffers are allocated in addition to mem_limit
	# optional, default is 1M
	#
	

	# maximum file field adaptive buffer size
	# optional, default is 8M, minimum is 1M
	#
	

	# how to handle IO errors in file fields
	# known values are 'ignore_field', 'skip_document', and 'fail_index'
	# optional, default is 'ignore_field'
	#
	

	# lemmatizer cache size
	# improves the indexing time when the lemmatization is enabled
	# optional, default is 256K
	#
	# lemmatizer_cache = 64M
}

#############################################################################
## searchd settings
#############################################################################

searchd
{
    #data_dir = /var/lib/manticore

	# [hostname:]port[:protocol], or /unix/socket/path to listen on
	# known protocols are 'sphinx' (SphinxAPI) and 'mysql41' (SphinxQL)
	#
	# multi-value, multiple listen points are allowed
	# optional, defaults are 9312:sphinx and 9306:mysql41, as below
	#
	# listen			= 127.0.0.1
	# listen			= 192.168.0.1:9312
	# listen			= 9312
	# listen			= /var/run/searchd.sock
	listen			= 9312
	listen          = 9308:http
	listen			= 9306:mysql41

	# log file, searchd run info is logged here
	# optional, default is 'searchd.log'
	log			=  /var/log/manticore/searchd.log

	# query log file, all search queries are logged here
	# optional, default is empty (do not log queries)
	query_log		= /var/log/manticore/query.log
    query_log_format = sphinxql


    
	# client read timeout, seconds
	# optional, default is 5
	read_timeout		= 30

	# request timeout, seconds
	# optional, default is 5 minutes
	client_timeout		= 600

	# maximum amount of children to fork (concurrent searches to run)
	# optional, default is 0 (unlimited)
	max_children		= 800

	# maximum amount of persistent connections from this master to each agent host
	# optional, but necessary if you use agent_persistent. It is reasonable to set the value
	# as max_children, or less on the agent's hosts.
	persistent_connections_limit	= 500

	# PID file, searchd process ID file name
	# mandatory
	pid_file		= /var/run/manticore/searchd.pid

	# seamless rotate, prevents rotate stalls if precaching huge datasets
	# optional, default is 1
	seamless_rotate		= 1

	# whether to forcibly preopen all indexes on startup
	# optional, default is 1 (preopen everything)
	preopen_indexes		= 1

	# whether to unlink .old index copies on succesful rotation.
	# optional, default is 1 (do unlink)
	unlink_old		= 1

	# attribute updates periodic flush timeout, seconds
	# updates will be automatically dumped to disk this frequently
	# optional, default is 0 (disable periodic flush)
	#
	 attr_flush_period	= 900


	# MVA updates pool size
	# shared between all instances of searchd, disables attr flushes!
	# optional, default size is 1M
	mva_updates_pool	= 1M

	# max allowed network packet size
	# limits both query packets from clients, and responses from agents
	# optional, default size is 8M
	max_packet_size		= 128M

	# max allowed per-query filter count
	# optional, default is 256
	max_filters		= 512

	# max allowed per-filter values count
	# optional, default is 4096
	max_filter_values	= 8192


	# socket listen queue length
	# optional, default is 5
	#
	

	# per-keyword read buffer size
	# optional, default is 256K
	#
	

	# unhinted read size (currently used when reading hits)
	# optional, default is 32K
	#
	

	# max allowed per-batch query count (aka multi-query count)
	# optional, default is 32
	max_batch_queries	= 64


	# max common subtree document cache size, per-query
	# optional, default is 0 (disable subtree optimization)
	#
	

	# max common subtree hit cache size, per-query
	# optional, default is 0 (disable subtree optimization)
	#
	

	# multi-processing mode (MPM)
	# known values are none, fork, prefork, and threads
	# threads is required for RT backend to work
	# optional, default is threads
	workers			= threads # for RT to work


	# max threads to create for searching local parts of a distributed index
	# optional, default is 0, which means disable multi-threaded searching
	# should work with all MPMs (ie. does NOT require workers=threads)
	#
	

	# binlog files path; use empty string to disable binlog
	# optional, default is build-time configured data directory
	#
	binlog_path		= /var/lib/manticore
	

	# binlog flush/sync mode
	# 0 means flush and sync every second
	# 1 means flush and sync every transaction
	# 2 means flush every transaction, sync every second
	# optional, default is 2
	#
    binlog_flush = 2
	

	# binlog per-file size limit
	# optional, default is 128M, 0 means no limit
	#
    binlog_max_log_size = 268435456
	

	# per-thread stack size, only affects workers=threads mode
	# optional, default is 64K
	#
	

	# per-keyword expansion limit (for dict=keywords prefix searches)
	# optional, default is 0 (no limit)
	#
	
	# RT RAM chunks flush period
	# optional, default is 0 (no periodic flush)
	#
	

	# query log file format
	# optional, known values are plain and sphinxql, default is plain
	#
	

	# version string returned to MySQL network protocol clients
	# optional, default is empty (use Sphinx version)
	#
	

	# default server-wide collation
	# optional, default is libc_ci
	#
	

	# server-wide locale for libc based collations
	# optional, default is C
	#
	

	# threaded server watchdog (only used in workers=threads mode)
	# optional, values are 0 and 1, default is 1 (watchdog on)
	#
	

	# costs for max_predicted_time model, in (imaginary) nanoseconds
	# optional, default is "doc=64, hit=48, skip=2048, match=64"
	#
	

	# current SphinxQL state (uservars etc) serialization path
	# optional, default is none (do not serialize SphinxQL state)
	#
	

	# maximum RT merge thread IO calls per second, and per-call IO size
	# useful for throttling (the background) OPTIMIZE INDEX impact
	# optional, default is 0 (unlimited)
	#
		

	# interval between agent mirror pings, in milliseconds
	# 0 means disable pings
	# optional, default is 1000
	#
	

	# agent mirror statistics window size, in seconds
	# stats older than the window size (karma) are retired
	# that is, they will not affect master choice of agents in any way
	# optional, default is 60 seconds
	#
	

	# delay between preforked children restarts on rotation, in milliseconds
	# optional, default is 0 (no delay)
	#
	

	# a prefix to prepend to the local file names when creating snippets
	# with load_files and/or load_files_scatter options
	# optional, default is empty
	#
}

#############################################################################
## common settings
#############################################################################

common
{

    json_autoconv_numbers = 1

	# lemmatizer dictionaries base path
	# optional, defaut is /usr/local/share (see ./configure --datadir)
	#
	# lemmatizer_base = /usr/local/share/sphinx/dicts

	# how to handle syntax errors in JSON attributes
	# known values are 'ignore_attr' and 'fail_index'
	# optional, default is 'ignore_attr'
	#
	

	# whether to auto-convert numeric values from strings in JSON attributes
	# with auto-conversion, string value with actually numeric data
	# (as in {"key":"12345"}) gets stored as a number, rather than string
	# optional, allowed values are 0 and 1, default is 0 (do not convert)
	#
	

	# whether and how to auto-convert key names in JSON attributes
	# known value is 'lowercase'
	# optional, default is unspecified (do nothing)
	#
	

	# path to RLP root directory
	# optional, defaut is /usr/local/share (see ./configure --datadir)
	#
	

	# path to RLP environment file
	# optional, defaut is /usr/local/share/rlp-environment.xml (see ./configure --datadir)
	#
	

	# maximum total size of documents batched before processing them by the RLP
	# optional, default is 51200
	#
	

	# maximum number of documents batched before processing them by the RLP
	# optional, default is 50
	#
	

	# trusted plugin directory
	# optional, default is empty (disable UDFs)
	#
	
}

# --eof--
